:PROPERTIES:
:ID:       5ba2a1d7-01fb-49f1-b453-0448171f87bc
:END:
#+SETUPFILE: blog.setup
#+filetags:
#+CREATED: 2023-08-24
#+HUGO_DRAFT: false
#+title: Parse podcast transcripts from Lage der Nation

I regularly listen to the podcast [[https://lagedernation.org/][Lage der Nation]], which offers transcripts to
premium subscribers on their website lage.ladernation.org. To export quotes from
a recent episode and add them to my private knowledge database, I followed these
steps:

1. I became a premium subscriber to gain access to the transcripts.
2. I activated the developer console in my browser.
3. In the network tab of the console, I saw a ~GET~ request to a URL like ~https://plus.lagedernation.org/<...>/?podlove_transcript=json~, which fetches the JSON version of the transcripts, provided by [[https://podlove.org/][podlove]].


Here is some snippet from the JSON file:

#+caption: Podcast transcripts in JSON format
#+begin_src json
[
  {
    "start": "00:00:04.500",
    "start_ms": 4500,
    "end": "00:00:06.569",
    "end_ms": 6569,
    "speaker": "2",
    "voice": "Philip",
    "text": "weiteren Sommerfolge mit einem"
  },
  {
    "start": "00:00:06.570",
    "start_ms": 6570,
    "end": "00:00:08.849",
    "end_ms": 8849,
    "speaker": "2",
    "voice": "Philip",
    "text": "weiteren ausführlichen Interview."
  },
  [...]
  {
    "start": "00:13:41.850",
    "start_ms": 821850,
    "end": "00:13:43.949",
    "end_ms": 823949,
    "speaker": "152",
    "voice": "Jochem Marotzke",
    "text": "Ich glaube, da hilft ein"
  },
  [...]
]
#+end_src

My desired output:

#+caption: Desired output
#+begin_example
Philipp:
[text]


Jochem Marotzke:
[text]
#+end_example

I'm using [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]].


#+caption: ChatGPT prompt
#+begin_src shell
ChatGPT(3.5t/Programming)> I would like to write a simple Golang tool which will parse following JSON
[
  {
    "start": "00:00:04.500",
    "start_ms": 4500,
    "end": "00:00:06.569",
    "end_ms": 6569,
    "speaker": "2",
    "voice": "Philip",
    "text": "weiteren Sommerfolge mit einem"
  },
  {
    "start": "00:00:06.570",
    "start_ms": 6570,
    "end": "00:00:08.849",
    "end_ms": 8849,
    "speaker": "2",
    "voice": "Philip",
    "text": "weiteren ausführlichen Interview."
  },
]

First I want to print out the voice attribute and then the text one. Unless the voice attribute doesn't change I want the text of the voice attribute to be printed without newlines. In case the voice attribute changes I want to a double newline to be printed out and then print again the voice attribute.
#+end_src

#+caption: ChatGPT response
#+begin_src markdown

You can achieve what you described by parsing the JSON data and then iterating over the array of objects. For each object, you can keep track of the previous voice attribute and compare it with the current one to determine if a newline should be printed.

Here's a simple example code snippet to get you started:

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
)

type Item struct {
	Start    string `json:"start"`
	StartMs  int    `json:"start_ms"`
	End      string `json:"end"`
	EndMs    int    `json:"end_ms"`
	Speaker  string `json:"speaker"`
	Voice    string `json:"voice"`
	Text     string `json:"text"`
}

func main() {
	// Read the JSON data from a file or any other source
	data, err := ioutil.ReadFile("data.json")
	if err != nil {
		fmt.Println("Error reading JSON file:", err)
		return
	}

	var items []Item
	err = json.Unmarshal(data, &items)
	if err != nil {
		fmt.Println("Error parsing JSON:", err)
		return
	}

	prevVoice := ""
	for _, item := range items {
		if item.Voice != prevVoice {
			// Print a double newline if the voice attribute changes
			fmt.Println("\n\n", item.Voice)
			prevVoice = item.Voice
		} else {
			// Print the text attribute without a newline
			fmt.Print(" ")
		}
		fmt.Print(item.Text)
	}

	fmt.Println() // Print a newline at the end
}
```

Make sure to replace `"data.json"` with the path to your JSON file. The code reads the JSON file, parses it into a slice of `Item` structs, and then iterates over the items while printing the voice and text attributes according to your requirements.

#+end_src


#+caption: ChatGPT prompt
#+begin_src shell
ChatGPT(3.5t/Programming)> Change the program so that it accepts a CLI argument to specify the file.
#+end_src

#+caption: ChatGPT response
#+begin_src markdown
To modify the program to accept a command-line argument for the JSON file, you can use the `os` package in Go. Here's an updated version of the code that incorporates this change:

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
)

type Item struct {
	Start   string `json:"start"`
	StartMs int    `json:"start_ms"`
	End     string `json:"end"`
	EndMs   int    `json:"end_ms"`
	Speaker string `json:"speaker"`
	Voice   string `json:"voice"`
	Text    string `json:"text"`
}

func main() {
	// Check if the file path is provided as a command-line argument
	if len(os.Args) < 2 {
		fmt.Println("Please provide the JSON file path as a command-line argument.")
		return
	}

	filePath := os.Args[1]

	// Read the JSON file
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		fmt.Println("Error reading JSON file:", err)
		return
	}

	var items []Item
	err = json.Unmarshal(data, &items)
	if err != nil {
		fmt.Println("Error parsing JSON:", err)
		return
	}

	prevVoice := ""
	for _, item := range items {
		if item.Voice != prevVoice {
			// Print a double newline if the voice attribute changes
			fmt.Println("\n\n", item.Voice)
			prevVoice = item.Voice
		} else {
			// Print the text attribute without a newline
			fmt.Print(" ")
		}
		fmt.Print(item.Text)
	}

	fmt.Println() // Print a newline at the end
}
```

Now you can run the program with the JSON file path as a command-line argument like this:

```shell
go run main.go data.json
```

Replace `main.go` with the name of your Go source file, and `data.json` with the actual path to your JSON file.

#+end_src
