#+title: Mastering Golang Debugging in Emacs
#+author: Victor Dorneanu
#+date: 2024-11-05
#+setupfile: setup.org
#+draft: true
#+property: header-args :mkdirp yes
#+macro: imglocal http://127.0.0.1:8888/public/img/$1

* Introduction

Since I've started developing in Golang I didn't use quite use the debugger. Instead I was naively adding ~fmt.Print~ statements everywhere to validate my code ðŸ™ˆ. While print statements and logs might be also your first debugging instinct, they often fall short when dealing with large and complex code base, with sophisticated runtime behaviour and (of course!) complex concurrency issues that seem impossible to reproduce.

After starting working on more complex projects I had to force myself to have a deeper look at ~delve~ (the Golang debugger) and see what Emacs offers for interacting with it. While the Go ecosystem offers excellent debugging tools (TODO: Add here list), integrating them into a comfortable development workflow can be challenging. 

In this post I'll elaborate the powerful combination of Emacs, Delve, and dape. Together, these tools create a debugging experience that mimics (and often surpasses) traditional IDEs, while preserving the flexibility and extensibility that Emacs is famous for.

This is what you can expect:
- Set up and configure [[https://github.com/go-delve/delve][Delve]] with [[https://github.com/svaante/dape][dape]]
- Debug both standard applications and [[https://github.com/onsi/ginkgo][Ginkgo]] tests (this is what I'm using at the moment ðŸ¤·)
- Utilize advanced debugging features like conditional breakpoints 
- Optimize your debugging workflow with Emacs specific customizations

* Setting Up the Development Environment

In this post I assume you already have some Emacs experience and now how to configure packages and write small ~Elisp~  snippets. I personally use [[https://github.com/radian-software/straight.el][straight.el]] as a package manager, [[https://github.com/jamescherti/minimal-emacs.d][minimal-emacs.d]] as a minimal vanilla Emacs configuration (along with my own [[https://github.com/dorneanu/dotfiles/blob/master/minimal-emacs/config.org][custommizations)]], [[https://github.com/svaante/dape][dape]] as the debug adapter client and [[https://github.com/joaotavora/eglot][eglot]] as my LSP client.

** Required Emacs Packages

For Emacs 29+ users, ~eglot~ is built-in.
#+begin_sidenote
Check out [[https://github.com/golang/tools/blob/master/gopls/doc/emacs.md#configuring-eglot][configuring eglot for gopls]] and some more advanced [[https://github.com/golang/tools/blob/master/gopls/doc/settings.md][gopls settings]].
#+end_sidenote

We'll first add ~dape~:

#+begin_src elisp
(use-package dape
  :straight t
  :config
  ;; Pulse source line (performance hit)
  (add-hook 'dape-display-source-hook 'pulse-momentary-highlight-one-line)

  ;; To not display info and/or buffers on startup
  ;; (remove-hook 'dape-start-hook 'dape-info)
  (remove-hook 'dape-start-hook 'dape-repl))
#+end_src

and ~go-mode~:

#+begin_src elisp
(use-package go-mode
  :straight t
  :mode "\\.go\\'"
  :hook ((before-save . gofmt-before-save))
  :bind (:map go-mode-map
              ("M-?" . godoc-at-point)
              ("M-." . xref-find-definitions)
              ("M-_" . xref-find-references)
              ;; ("M-*" . pop-tag-mark) ;; Jump back after godef-jump
              ("C-c m r" . go-run))
  :custom
  (gofmt-command "goimports"))
#+end_src

** Installing Required Go Tools

Install Delve and [[https://pkg.go.dev/golang.org/x/tools/gopls][gopls]], the LSP server:

#+caption: Install the Golang debugger and LSP server
#+begin_src bash
# Install Delve
go install github.com/go-delve/delve/cmd/dlv@latest

# Install gopls
go install golang.org/x/tools/gopls@latest
#+end_src

Additionally I have a bunch of other tools which I use from time to time:

#+caption: Additional tools
#+begin_src bash
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
go install github.com/onsi/ginkgo/v2/ginkgo@latest

go install -v golang.org/x/tools/cmd/godoc@latest
go install -v golang.org/x/tools/cmd/goimports@latest
go install -v github.com/stamblerre/gocode@latest
go install -v golang.org/x/tools/cmd/gorename@latest
go install -v golang.org/x/tools/cmd/guru@latest
go install -v github.com/cweill/gotests/...@latest

go install -v github.com/davidrjenni/reftools/cmd/fillstruct@latest
go install -v github.com/fatih/gomodifytags@latest
go install -v github.com/godoctor/godoctor@latest
go install -v github.com/haya14busa/gopkgs/cmd/gopkgs@latest
go install -v github.com/josharian/impl@latest
go install -v github.com/rogpeppe/godef@latest
#+end_src

Then you need to configure the corresponding Emacs packages:

#+begin_src elisp
(use-package ginkgo
  :straight (:type git :host github :repo "garslo/ginkgo-mode")
  :init
  (setq ginkgo-use-pwd-as-test-dir t
        ginkgo-use-default-keys t))

(use-package gotest
  :straight t
  :after go-mode
  :bind (:map go-mode-map
              ("C-c t f" . go-test-current-file)
              ("C-c t t" . go-test-current-test)
              ("C-c t j" . go-test-current-project)
              ("C-c t b" . go-test-current-benchmark)
              ("C-c t c" . go-test-current-coverage)
              ("C-c t x" . go-run)))

(use-package go-guru
  :straight t
  :hook
  (go-mode . go-guru-hl-identifier-mode))

(use-package go-projectile
  :straight t
  :after (projectile go-mode))

(use-package flycheck-golangci-lint
  :straight t
  :hook
  (go-mode . flycheck-golangci-lint-setup))

(use-package go-eldoc
  :straight t
  :hook
  (go-mode . go-eldoc-setup))

(use-package go-tag
  :straight t
  :bind (:map go-mode-map
              ("C-c t a" . go-tag-add)
              ("C-c t r" . go-tag-remove))
  :init (setq go-tag-args (list "-transform" "camelcase")))

(use-package go-fill-struct
  :straight t)

(use-package go-impl
  :straight t)

(use-package go-playground
  :straight t)

#+end_src

** Dape Configuration

There is no particular reason why I use ~dape~ instead of [[https://github.com/emacs-lsp/dap-mode][dap]]. When I was still using [[https://github.com/abougouffa/minemacs][MinEmacs]] it was part of it and I just got used to it. As the [[https://github.com/svaante/dape?tab=readme-ov-file#differences-with-dap-mode][documentation]] states:

#+begin_quote
- Dape does not support launch.json files, if per project configuration is
  needed use dir-locals and dape-command.
- Dape enhances ergonomics within the minibuffer by allowing users to modify or
  add PLIST entries to an existing configuration using options. For example
  dape-config :cwd default-directory :program ï¼‚/home/user/b.outï¼‚ compile ï¼‚gcc
  -g -o b.out main.cï¼‚.
- No magic, no special variables like ${workspaceFolder}. Instead, functions and
  variables are resolved before starting a new session.
- Tries to envision how debug adapter configurations would be implemented in
  Emacs if vscode never existed.
#+end_quote

If you ever worked with VSCode you already know that it uses a ~launch.json~ to store different debugging profiles. 

#+caption: Sample configuration to debug the current file
#+begin_src json
{
	"name": "Launch file",
	"type": "go",
	"request": "launch",
	"mode": "auto",
	"program": "${file}"
}
#+end_src

You have different fields/properties which according to [[https://github.com/microsoft/vscode-go/blob/master/docs/Debugging-Go-code-using-VS-Code.md][this page]] you can tweak in your debugging configuration:

#+caption: Properties to use for the Golang debugger
| Property   | Description                                                                                                                                                                                         |
|------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| name       | Name for your configuration that appears in the drop down in the Debug viewlet                                                                                                                      |
| type       | Always set to "go". This is used by VS Code to figure out which extension should be used for debugging your code                                                                                    |
| request    | Either of `launch` or `attach`. Use `attach` when you want to attach to an already running process.                                                                                                 |
| mode       | For launch requests, either of `auto`, `debug`, `remote`, `test`, `exec`. For attach requests, use either `local` or `remote`                                                                       |
| program    | Absolute path to the package or file to debug when in `debug` & `test` mode, or to the pre-built binary file to debug in `exec` mode. Not applicable to attach requests.                            |
| env        | Environment variables to use when debugging. Example: `{ "ENVNAME": "ENVVALUE" }`                                                                                                                   |
| envFile    | Absolute path to a file containing environment variable definitions. The environment variables passed in the `env` property overrides the ones in this file.                                        |
| args       | Array of command line arguments that will be passed to the program being debugged.                                                                                                                  |
| showLog    | Boolean indicating if logs from delve should be printed in the debug console                                                                                                                        |
| logOutput  | Comma separated list of delve components (`debugger`, `gdbwire`, `lldbout`, `debuglineerr`, `rpc`) that should produce debug output when `showLog` is set to `true`.                                |
| buildFlags | Build flags to be passed to the Go compiler                                                                                                                                                         |
| remotePath | Absolute path to the file being debugged on the remote machine in case of remote debugging i.e when `mode` is set to `remote`. See the section on [Remote Debugging](#remote-debugging) for details |
| processId  | Applicable only when using the `attach` request with `local` mode. This is the id of the process that is running your executable which needs debugging.                                             |

In ~dape~ you can use these properties to setup ~dape-configs~:

#+begin_src elisp
;; Basic dape configuration
(with-eval-after-load 'dape
  ;; Add Go debug configuration
  (add-to-list 'dape-configs
               `(go-debug-main
                 modes (go-mode go-ts-mode)
                 command "dlv"
                 command-args ("dap" "--listen" "127.0.0.1::autoport")
                 command-cwd dape-command-cwd
                 port :autoport
                 :type "debug"
                 :request "launch"
                 :name "Debug Go Program"
                 :cwd "."
                 :program "."
                 :args [])))
#+end_src

Usually I like to store my different debugging profiles in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html][directory variables]] (stored in ~.dir-locals.el~). At the root of each project (you can as well have different configs per folder/package) I store my debugging profiles like this:

#+caption: Debugging profiles in ~.dir-locals.el~
#+begin_src elisp
((go-mode . ((dape-configs .
        ((go-debug-main
          modes (go-mode go-ts-mode)
          command "dlv"
          command-args ("dap" "--listen" "127.0.0.1:55878" "--log-dest" "/tmp/dlv.log")
          command-cwd "/home/victor/projects/repo1"
          host "127.0.0.1"
          port 55878
          :request "launch"
          :mode "debug"
          :type "go"
          :showLog "true"
          :program "/home/victor/projects/repo1/main.go")
         (go-test
          modes (go-mode go-ts-mode)
          command "dlv"
          command-args ("dap" "--listen" "127.0.0.1:55878")
          command-cwd "/home/victor/projects/repo1"
          host "127.0.0.1"
          port 55878
          :request "launch"
          :mode "test"
          :type "go"
          :program "/home/victor/projects/repo1/test/some_file_test.go")
         (go-test-ginkgo
          modes (go-mode go-ts-mode)
          command "dlv"
          command-args ("dap" "--listen" "127.0.0.1:55878")
          command-cwd "/home/victor/projects/repo1/"
          host "127.0.0.1"
          port 55878
          :request "launch"
          :mode "test"
          :type "go"
          :showLog "true"
          :args ["-ginkgo.v" "-ginkgo.focus" "MyGinkgoTest*"]
          :program "/home/victor/projects/repo1/package/"))))))
#+end_src

* Sample Application
Now let's put our knowledge into practice by debugging a real application implementint a REST API. 
** Project Structure

Our example is a REST API for task management with the following structure:

#+begin_src
taskapi/
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ main.go
â”œâ”€â”€ task_store.go
â””â”€â”€ task_test.go
#+end_src

** Core Components
:properties:
:header-args:go: :tangle (org-sbe code-dir (filename \"task_store.go\")) :main no
:end:

Let's have a look at the *core components*.

The ~Task~ represents our core domain model which we'll use to demonstrate different debugging scenarios:

#+caption: task_store.go: Task entity
#+begin_src go
type Task struct {
    ID          int    `json:"id"`
    Title       string `json:"title"`
    Description string `json:"description"`
    Done        bool   `json:"done"`
}
#+end_src


The ~TaskStore~ handles our in-memory data operations:

#+caption: task_store.go: The TaskStore storing multiple tasks
#+begin_src go
type TaskStore struct {
    tasks  map[int]Task
    nextID int
}

func NewTaskStore() *TaskStore {
	return &TaskStore{
		tasks:  make(map[int]Task),
		nextID: 1,
	}
}

#+end_src

*** REST API
:properties:
:header-args:go: :tangle (org-sbe code-dir (filename \"task_store.go\")) :main no
:end:

The API should expose following endpoints: 
- =POST /task/create= - Creates a new task
- =GET /task/get?id=<id>= - Retrieves a task by ID

#+caption: task_store.go: Rest API handlers
#+begin_src go
// CreateTask stores a given Task internally
func (ts *TaskStore) CreateTask(task Task) Task {
	task.ID = ts.nextID
	ts.tasks[task.ID] = task
	ts.nextID++
	return task
}

// GetTask retrieves a Task by ID
func (ts *TaskStore) GetTask(id int) (Task, error) {
	task, exists := ts.tasks[id]
	if !exists {
		return Task{}, fmt.Errorf("task with id %d not found", id)
	}
	return task, nil
}

// UpdateTask updates task ID with a new Task object
func (ts *TaskStore) UpdateTask(id int, task Task) error {
	if _, exists := ts.tasks[id]; !exists {
		return fmt.Errorf("task with id %d not found", id)
	}
	task.ID = id
	ts.tasks[id] = task
	return nil
}

#+end_src
**** Server
:properties:
:header-args:go: :tangle (org-sbe code-dir (filename \"task_server.go\")) :main no
:end:

Let's continue with the server:

#+begin_src go
package main

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// Server implements a web application for managing tasks
type Server struct {
	store *TaskStore
}

func (s *Server) handleCreateTask(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	var task Task
	if err := json.NewDecoder(r.Body).Decode(&task); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	createdTask := s.store.CreateTask(task)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(createdTask)
}

func (s *Server) handleGetTask(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	// For demonstration, we'll extract ID from query parameter
	id := 0
	fmt.Sscanf(r.URL.Query().Get("id"), "%d", &id)

	task, err := s.store.GetTask(id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(task)
}
#+end_src
** main package
:properties:
:header-args:go: :tangle (org-sbe code-dir (filename \"main.go\")) :main no
:end:

#+caption: main.go
#+begin_src go
package main

import (
	"log"
    "net/http"
)

func main() {
	store := NewTaskStore()
	server := &Server{store: store}
	http.HandleFunc("/task/create", server.handleCreateTask)
	http.HandleFunc("/task/get", server.handleGetTask)

	log.Printf("Starting server on :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}
#+end_src
** go.mod
:properties:
:header-args:go: :export both
:end:
Create Go module:

#+begin_src shell :dir (org-sbe code-dir (filename \"\"))
go mod init taskapi
go mod tidy
#+end_src

#+RESULTS:
#+caption: Results
#+begin_src shell
go: creating new go.mod: module taskapi
go: to add module requirements and sums:
	go mod tidy
go: finding module for package github.com/onsi/gomega
go: finding module for package github.com/onsi/ginkgo/v2
go: found github.com/onsi/ginkgo/v2 in github.com/onsi/ginkgo/v2 v2.21.0
go: found github.com/onsi/gomega in github.com/onsi/gomega v1.35.1
#+end_src

Check dependencies:
#+begin_src shell :dir (org-sbe code-dir (filename \"\")) :results code
cat go.mod
#+end_src

#+RESULTS:
#+caption: Results
#+begin_src shell
module taskapi

go 1.23.0

require (
	github.com/onsi/ginkgo/v2 v2.21.0
	github.com/onsi/gomega v1.35.1
)

require (
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-task/slim-sprig/v3 v3.0.0 // indirect
	github.com/google/go-cmp v0.6.0 // indirect
	github.com/google/pprof v0.0.0-20241029153458-d1b30febd7db // indirect
	golang.org/x/net v0.30.0 // indirect
	golang.org/x/sys v0.26.0 // indirect
	golang.org/x/text v0.19.0 // indirect
	golang.org/x/tools v0.26.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
#+end_src

** Build application
Let's start the server:

#+begin_src shell :dir (org-sbe code-dir (filename \"\")) :results code
go build -o taskapi *.go
ls -c
#+end_src

#+RESULTS:
#+begin_src shell
go.mod
main.go
task_server.go
task_store.go
taskapi
#+end_src

Now run it:
#+begin_src shell 
$ ./taskapi
2024/11/14 07:03:48 Starting server on :8080

#+end_src

Now from a different terminal *create* a new task:
#+begin_src shell :results output :wrap "src json" 
curl -X POST -s http://localhost:8080/task/create \
-H "Content-Type: application/json" \
-d '{"title":"Learn Debugging","description":"Master Emacs debugging with dape","done":false}'
#+end_src

#+RESULTS:
#+caption: Results
#+begin_src json
{"id":3,"title":"Learn Debugging","description":"Master Emacs debugging with dape","done":false}
#+end_src

Let's see if we can fetch it:

#+begin_src shell :results output :wrap "src json" 
curl -X GET -s "http://localhost:8080/task/get?id=1"
#+end_src

#+RESULTS:
#+caption: Results
#+begin_src json
{"id":1,"title":"Learn Debugging","description":"Master Emacs debugging with dape","done":false}
#+end_src


** Unit tests
:properties:
:header-args:go: :tangle (org-sbe code-dir (filename \"task_store_test.go\")) :main no
:end:
Below are some unit tests (writen in Ginkgo) for the ~TaskStore~:

#+caption: task_test.go
#+begin_src go
package main
import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"testing"
)

func TestTasks(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Task API Suite")
}


var _ = Describe("Task API", func() {
	var (
		store  *TaskStore
		server *Server
	)
	BeforeEach(func() {
		store = NewTaskStore()
		server = &Server{store: store}
	})

	Describe("POST /task/create", func() {
		Context("when creating a new task", func() {
			It("should create and return a task with an ID", func() {
				task := Task{
					Title:       "Test Task",
					Description: "Test Description",
					Done:        false,
				}

				payload, err := json.Marshal(task)
				Expect(err).NotTo(HaveOccurred())

				req := httptest.NewRequest(http.MethodPost, "/task/create",
					bytes.NewBuffer(payload))
				w := httptest.NewRecorder()

				server.handleCreateTask(w, req)

				Expect(w.Code).To(Equal(http.StatusOK))

				var response Task
				err = json.NewDecoder(w.Body).Decode(&response)
				Expect(err).NotTo(HaveOccurred())
				Expect(response.ID).To(Equal(1))
				Expect(response.Title).To(Equal("Test Task"))
			})

			It("should handle invalid JSON payload", func() {
				req := httptest.NewRequest(http.MethodPost, "/task/create",
					bytes.NewBufferString("invalid json"))
				w := httptest.NewRecorder()

				server.handleCreateTask(w, req)

				Expect(w.Code).To(Equal(http.StatusBadRequest))
			})
		})
	})

	Describe("GET /task/get", func() {
		Context("when fetching an existing task", func() {
			var createdTask Task

			BeforeEach(func() {
				task := Task{
					Title:       "Test Task",
					Description: "Test Description",
					Done:        false,
				}
				createdTask = store.CreateTask(task)
			})

			It("should return the correct task", func() {
				req := httptest.NewRequest(http.MethodGet, "/task/get?id=1", nil)
				w := httptest.NewRecorder()

				server.handleGetTask(w, req)

				Expect(w.Code).To(Equal(http.StatusOK))

				var response Task
				err := json.NewDecoder(w.Body).Decode(&response)
				Expect(err).NotTo(HaveOccurred())
				Expect(response).To(Equal(createdTask))
			})
		})

		Context("when fetching a non-existent task", func() {
			It("should return a 404 error", func() {
				req := httptest.NewRequest(http.MethodGet, "/task/get?id=999", nil)
				w := httptest.NewRecorder()

				server.handleGetTask(w, req)

				Expect(w.Code).To(Equal(http.StatusNotFound))
			})
		})

		Context("when using invalid task ID", func() {
			It("should handle non-numeric ID gracefully", func() {
				req := httptest.NewRequest(http.MethodGet, "/task/get?id=invalid", nil)
				w := httptest.NewRecorder()

				server.handleGetTask(w, req)

				Expect(w.Code).To(Equal(http.StatusNotFound))
			})
		})
	})
})
#+end_src

Add the Ginkgo dependencies to our ~go.mod~ file:
#+begin_src shell :dir (org-sbe code-dir (filename \"\")) :results code
go get github.com/onsi/ginkgo/v2@latest
go get github.com/onsi/gomega
#+end_src

Now we should have a full list of dependencies in our ~go.mod~ file:

#+begin_src shell :dir (org-sbe code-dir (filename \"\")) :results code
cat go.mod
#+end_src

#+RESULTS:
#+caption: Results
#+begin_src shell
module taskapi

go 1.23.0

require (
	github.com/onsi/ginkgo/v2 v2.21.0
	github.com/onsi/gomega v1.35.1
)

require (
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-task/slim-sprig/v3 v3.0.0 // indirect
	github.com/google/go-cmp v0.6.0 // indirect
	github.com/google/pprof v0.0.0-20241029153458-d1b30febd7db // indirect
	golang.org/x/net v0.30.0 // indirect
	golang.org/x/sys v0.26.0 // indirect
	golang.org/x/text v0.19.0 // indirect
	golang.org/x/tools v0.26.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
#+end_src

Let's run the tests:

#+begin_src shell :dir (org-sbe code-dir (filename \"\")) :results code
go test -v
#+end_src

#+RESULTS:
#+caption: Results
#+begin_src shell
=== RUN   TestTasks
Running Suite: Task API Suite - /home/victor/repos/priv/blog/static/code/2024/emacs-golang-debugging
======================================================================================================
Random Seed: [1m1731647885[0m

Will run [1m5[0m of [1m5[0m specs
[38;5;10mâ€¢[0m[38;5;10mâ€¢[0m[38;5;10mâ€¢[0m[38;5;10mâ€¢[0m[38;5;10mâ€¢[0m

[38;5;10m[1mRan 5 of 5 Specs in 0.001 seconds[0m
[38;5;10m[1mSUCCESS![0m -- [38;5;10m[1m5 Passed[0m | [38;5;9m[1m0 Failed[0m | [38;5;11m[1m0 Pending[0m | [38;5;14m[1m0 Skipped[0m
--- PASS: TestTasks (0.00s)
PASS
ok  	taskapi	0.193s
#+end_src


In Emacs I would then call ~ginkgo-run-this-container~ as shown in this screenshot: 

[[file:../../../blog/static/posts/img/2024/emacs-golang-debugging/emacs-ginkgo.png]]

* WIP Basic Debugging with Delve and Dape
In order to debug our Task API we have following approaches
- we can /launch/ the application directly and debug it
- we can /attach/ to a running process
- we can /attach/ to a running debugging session

#+caption: Options for different request types ([[https://github.com/go-delve/delve/blob/master/Documentation/api/dap/README.md][source]])
| request | mode   | required     | optional                                                     |
|---------+--------+--------------+--------------------------------------------------------------|
| /launch/  | debug  | program      | dlvCwd, env, backend, args, cwd, buildFlags, output, noDebug |
|         | test   | program      | dlvCwd, env, backend, args, cwd, buildFlags, output, noDebug |
|         | exec   | program      | dlvCwd, env, backend, args, cwd, noDebug                     |
|         | core   | program      | dlvCwd, env                                                  |
|         |        | corefilePath |                                                              |
|         | replay | traceDirPath | dlvCwd, env                                                  |
|---------+--------+--------------+--------------------------------------------------------------|
| /attach/  | local  | processId    | backend                                                      |
|         | remote |              |                                                              |
|---------+--------+--------------+--------------------------------------------------------------|

So for each ~request~ we have different ~modes~. For the ~attach~ request type I'll only focus on the ~remote~ mode which requires you to start the debugger externally and then use the DAP client (within Emacs) to connect to it. I couldn't find any way how to interactively select the process ID before starting the debugger client. Now let's delve into each workflow.

TODO: Describe different approaches described [[https://github.com/emacs-lsp/dap-mode/issues/318#issuecomment-1104813373][here]]. 
** Profile 1: Launch application

As I've mentioned at the beginning I like to keep my debugging profiles in ~.dir-locals~ for each propject:

#+caption: .dir-locals.el (only the launch debug profile is configured)
#+begin_src emacs-lisp :tangle (org-sbe code-dir (filename \".dir-locals.el\"))
((go-mode . ((dape-configs .
   ;; Profile 1: Launch application and start DAP server
   ((go-debug-taskapi
     modes (go-mode go-ts-mode)
     command "dlv"
     command-args ("dap" "--listen" "127.0.0.1:55878")
     command-cwd default-directory
     host "127.0.0.1"
     port 55878
     :request "launch"
     :mode "debug"
     :type "go"
     :showLog "true"
     :program "."))))))
#+end_src

ðŸ’¡ You may want to use a different value for ~command-cwd~ (the default setting is ~dape-cwd-fn~). In my case I wanted to start the debugger in a directory which currently is not a project. ~default-directory~ is a variable which holds the working directory for the current buffer you're currently in.

Start debugging:
- Run ~dape-info~ to show debugging information
  
  #+caption: Show debugging related buffers (on the left)
  [[file:../../../blog/static/posts/img/2024/emacs-golang-debugging/emacs-dape-info.png]]

- Create breakpoint using ~dape-breakpoint-toggle~:

  #+caption: Set breakpoint
  [[file:../../../blog/static/posts/img/2024/emacs-golang-debugging/emacs-dape-breakpoint.png]]

- Launch ~dape~

  In the ~dape-repl~ buffer you should something like:
  
  #+caption: The debugger compiled the binary and also launched it
  #+begin_src shell
  Available Dape commands: debug, next, continue, pause, step, out, up, down, restart, kill, disconnect, quit
  Empty input will rerun last command.

  DAP server listening at: 127.0.0.1:55878
  debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-1600.0.36.3
   for arm64.
  Got a connection, launched process /home/victor/repos/priv/blog/static/code/2024/emacs-golang-debugging/__debug_bin3666561508 (pid = 43984).
  Type 'dlv help' for list of commands.
  #+end_src

  You might have noticed that we didn't specify any binary/file to debug (we had ~:program "."~ in ~.dir-locals.el~). ~delve~ will automatically /build/ the binary before it launches the application:

  #+caption: How delve builds the application when you have ~:program "."~
  #+begin_src shell
  go build -gcflags=all="-N -l" .
  #+end_src
  
** Profile 2: Attach to an external debugger

Let's say you now want to connect to an existing debugging session: 

#+caption: Additional config for attaching to a running process
#+begin_src emacs-lisp :tangle (org-sbe code-dir (filename \".dir-locals.el\"))
((go-mode . ((dape-configs .
   ;; Profile 1: Launch application and start DAP server
   ((go-debug-taskapi
     modes (go-mode go-ts-mode)
     command "dlv"
     command-args ("dap" "--listen" "127.0.0.1:55878")
     command-cwd default-directory
     host "127.0.0.1"
     port 55878
     :request "launch"
     :mode "debug"
     :type "go"
     :showLog "true"
     :PROGRAM ".")
    ;; Profile 2: Attach to external debugger   
    (go-attach-taskapi
     modes (go-mode go-ts-mode)
     command "dlv"
     command-cwd default-directory
     host "127.0.0.1"   ;; can also be skipped
     port 55878
     :request "attach"  ;; this will run "dlv attach ..."  
     :mode "remote"     ;; connect to a running debugger session
     :type "go"
     :showLog "true"))))))
#+end_src

Now let's start the *debugger* on the CLI:

#+begin_src shell
~/emacs-golang-debugging $ go build -gcflags=all="-N -l" -o taskapi .
~/emacs-golang-debugging $ dlv debug taskapi --listen=localhost:55878 --headless
API server listening at: 127.0.0.1:55878
debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-1600.0.36.3
 for arm64.
Got a connection, launched process /home/victor/repos/priv/blog/static/code/2024/emacs-golang-debugging/__debug_bin794004190 (pid = 23979).
#+end_src

Now within Emacs you can launch ~dape~ and select the ~go-attach-taskapi~ profile:


#+DOWNLOADED: screenshot @ 2024-11-20 06:28:30
[[file:../../../blog/static/posts/img/2024/emacs-golang-debugging/emacs-attach-to-external-debugger.png]]


** Profile 3: Attach to a running process
 
In this scenario the application is /already/ running but you want to /attach/ the debugger to it and use Emacs to connect to the debugger session. First we launch the application:

#+caption: Start the taskapi application
#+begin_src shell
$ ./taskapi
2024/11/20 06:34:29 Starting server on :8080
#+end_src

Find out its process ID (PID):
#+begin_src shell :results code 
ps -A | grep -m1 taskapi | awk '{print $1}'
#+end_src

#+RESULTS:
#+caption: Find out PID of running process
#+begin_src shell
56491
#+end_src

Now attach debugger to the running process:
#+caption: Attach debugger to running process and start DAP server
#+begin_src shell
$ dlv attach 54854 --listen=localhost:55878 --headless
API server listening at: 127.0.0.1:55878
#+end_src

Now let's add a 3rd debug profile:

#+begin_src emacs-lisp :tangle (org-sbe code-dir (filename \".dir-locals.el\"))
((go-mode . ((dape-configs .
   ;; Profile 1: Launch application and start DAP server
   ((go-debug-taskapi
     modes (go-mode go-ts-mode)
     command "dlv"
     command-args ("dap" "--listen" "127.0.0.1:55878")
     command-cwd default-directory
     host "127.0.0.1"
     port 55878
     :request "launch"
     :mode "debug"
     :type "go"
     :showLog "true"
     :program ".")
     
    ;; Profile 2: Attach to external debugger   
    (go-attach-taskapi
     modes (go-mode go-ts-mode)
     command "dlv"
     command-cwd default-directory
     host "127.0.0.1"   ;; can also be skipped
     port 55878
     :request "attach"  ;; this will run "dlv attach ..."  
     :mode "remote"     ;; connect to a running debugger session
     :type "go"
     :showLog "true")
     
    ;; Profile 3: Attach to running process (by PID)
    (go-attach-pid
     modes (go-mode go-ts-mode)
     command "dlv"
     command-args ("dap" "--listen" "127.0.0.1:55878" "--log")
     command-cwd default-directory
     host "127.0.0.1"   
     port 55878
     :request "attach"  
     :mode "local"      ;; Attach to a running process local to the server     
     :type "go"
     :processId (+get-process-id-by-name "taskapi")
     :showLog "true")))

     ;; Add helpful function 
     (eval . (progn
               (defun +get-process-id-by-name (process-name)
                 "Return the process ID of a process specified by PROCESS-NAME. Works on Unix-like systems (Linux, MacOS)."
                 (interactive)
                 (let ((pid nil))
                   (cond
                    ((memq system-type '(gnu/linux darwin))
                     (setq pid (shell-command-to-string 
                                (format "pgrep -f %s" 
                                        (shell-quote-argument process-name)))))
                    (t
                     (error "Unsupported system type: %s" system-type)))

                   ;; Clean up the output and return first PID
                   (when (and pid (not (string-empty-p pid)))
                     (car (split-string pid "\n" t))))))))))

#+end_src

I've also added ~+get-process-id-by-name~ which will return the process ID for the ~taskapi~ application. 
Now you can use the same debug profile (~go-attach-taskapi~) to connect to the debugger:


* TODO Advanced Debugging Techniques

** Extended Debug Configurations

#+begin_src elisp
;; Configuration for debugging with environment variables
(add-to-list 'dape-configs
             `(debug-task-api-with-env
               modes (go-mode)
               command "dlv"
               command-args ("dap" "--listen" "127.0.0.1:${:port}")
               command-cwd dape-cwd-fn
               port :autoport
               :type "debug"
               :request "launch"
               :name "Debug with Environment"
               :program ,(expand-file-name "./main.go")
               :env ((list "APP_ENV" "development")
                    (list "DEBUG_LEVEL" "debug"))))
#+end_src

** Remote Debugging

*** Setting Up Remote Debugging

1. On remote machine:
#+begin_src bash
dlv debug --headless --listen=:2345 --api-version=2 --accept-multiclient ./main.go
#+end_src

2. Local configuration:
#+begin_src elisp
(add-to-list 'dape-configs
             `(remote-debug-config
               modes (go-mode)
               command nil  ; No local command needed
               :type "debug"
               :request "attach"
               :name "Remote Debug"
               :mode "remote"
               :host "remote-host"
               :port 2345
               :substitutePath [("/remote/path" "/local/path")]))
#+end_src

* TODO Debugging Ginkgo Tests

** Dape Configuration for Ginkgo

#+begin_src elisp
(add-to-list 'dape-configs
             `(debug-ginkgo-tests
               modes (go-mode)
               command "dlv"
               command-args ("dap" "--listen" "127.0.0.1:${:port}")
               command-cwd dape-cwd-fn
               port :autoport
               :type "debug"
               :request "launch"
               :name "Debug Ginkgo Tests"
               :mode "test"
               :program ,(expand-file-name "./")
               :args ["ginkgo" "--v" "--focus" "${focusString}"]
               :buildFlags ["-tags=testing"]))
#+end_src

** Helper Functions

#+begin_src elisp
(defun my/dape-debug-ginkgo-focus (focus-string)
  "Start debugging Ginkgo tests with a specific focus string."
  (interactive "sEnter focus string: ")
  (let ((dape-configs (list
                      `(debug-focused-test
                        modes (go-mode)
                        command "dlv"
                        command-args ("dap" "--listen" "127.0.0.1:${:port}")
                        command-cwd dape-cwd-fn
                        port :autoport
                        :type "debug"
                        :request "launch"
                        :name "Debug Focused Test"
                        :mode "test"
                        :program ,(expand-file-name "./")
                        :args ["ginkgo" "--v" "--focus" ,focus-string]))))
    (dape)))
#+end_src

** Common Test Debugging Patterns

#+begin_src elisp
;; Watch expression for test setup
(defun my/watch-test-setup ()
  (interactive)
  (dape-watch-dwim "store")
  (dape-watch-dwim "server")
  (dape-watch-dwim "server.store.tasks"))

;; Watch expression for test data
(defun my/watch-test-task ()
  (interactive)
  (dape-watch-dwim "task")
  (dape-watch-dwim "payload")
  (dape-watch-dwim "string(payload)"))
#+end_src

* TODO Best Practices and Tips

- Always use version control to track your debugging configurations
- Keep debug configurations in a separate file (e.g., =.dir-locals.el=)
- Use meaningful names for debug configurations
- Consider creating project-specific debugging helper functions
- Document common debugging workflows for your team

* TODO Troubleshooting

** Common Issues

1. Dape connection issues:
   #+begin_src elisp
   ;; Try setting explicit port
   (setq dape-default-port 2345)
   #+end_src

2. Delve not found:
   #+begin_src bash
   # Add to your shell configuration
   export PATH=$PATH:$(go env GOPATH)/bin
   #+end_src

3. Project recognition:
   - Ensure valid =go.mod= file exists
   - Check if in Git repository (recommended)
   - Try restarting eglot

* TODO Resources and References
- 2024-11-19 â—¦ [[https://github.com/golang/vscode-go/blob/master/docs/debugging.md][vscode-go/docs/debugging.md at master Â· golang/vscode-go Â· GitHub]]
- 2024-11-19 â—¦ [[https://github.com/emacs-lsp/dap-mode/issues/318][support delve/dlv dap-mode directly Â· Issue #318 Â· emacs-lsp/dap-mode Â· GitHub]]
- [[https://github.com/svaante/dape][Dape GitHub Repository]]
- [[https://github.com/go-delve/delve][Delve Debugger]]
- [[https://github.com/joaotavora/eglot][Eglot Documentation]]
- [[https://onsi.github.io/ginkgo/][Ginkgo Testing Framework]]
#+end_src
* Config                                                           :noexport:
This are some configuration variables:

#+name: code-dir
#+begin_src emacs-lisp :exports none :var filename=""
(princ (concat "~/repos/priv/blog/static/code/2024/emacs-golang-debugging/" filename))
#+end_src

#+name: image-dir
#+begin_src emacs-lisp :exports none :var filename=""
(princ (concat "~/repos/priv/blog/static/posts/img/2024/emacs-golang-debugging/" filename))
#+end_src

# Local variables:
# org-download-image-dir: "~/repos/priv/blog/static/posts/img/2024/emacs-golang-debugging/"
# org-download-screenshot-basename: ".png"
# org-download-heading-lvl: nil
# org-agenda-files: nil
# org-export-babel-evaluate: nil
# end:
